#!/usr/bin/env bash

# Git Monitor
# Based on git-sync by Simon Thum (Add URL here)
# And the following:
# Took this from: https://github.com/ivanmalison/dotfiles/blob/3a0c142760a930fd41441a645d78ec2a83bf7811/dotfiles/lib/bin/git_sync_directory.sh#L8
# But the fswatch part from: https://github.com/gitwatch/gitwatch/blob/master/gitwatch.sh
# TODO add my own license

# NB we don't care about branches etc.
# We simply sync the current branch with upstream
# So there has to be an upstream
# And a branch on that upstream remote with same name
# Any complication on git status? Just don't do anything

# NB purpose: single-user, small (text) docs share


# Note: we DO auto-add new files. Maybe in the future use a limit on file size or number?

# Requirements: bash; git; coreutils and fswatch on Mac OS

# No windows support

declare -r TIMEOUT=60  # How long to wait for changes before we fetch/pull
declare -r MAX_NEW=10  # How many new files do we auto-commit?
declare -r MAX_NEW_SIZE=1000  # What is the max file size of new files to auto-commit (in kilobytes)?

# shellcheck disable=SC2155
declare -r SYSTEM="$(uname)"

readlink="readlink"
du="du"
wc="wc"
wait_for_change="inotifywait . -r -e modify,move,create,delete --format %w%f --exclude \\.git -t $TIMEOUT"

if [[ $SYSTEM = "Darwin" ]]; then
    command -v gtimeout >/dev/null || error_nowarn 1 "Please install coreutils."
    command -v fswatch >/dev/null || error_nowarn 1 "Please install fswatch."
    readlink="greadlink"
    du="gdu"
    wc="gwc"
    wait_for_change="gtimeout $TIMEOUT fswatch --recursive --event=414 --exclude \\.git  -1 ."
fi

##### Logging and Notification #####

msg() {
    # log message with date and target dir
    printf "[%s %s] %s\n" "$TARGET" "$(date '+%Y-%m-%d %H:%M:%S')" "$*"
}


warn() {
    # log message and show it as a system notification
    msg "$*"
    if [[ $SYSTEM = Darwin ]]; then
        osascript -e "display notification \"git-monitor on '$TARGET': $*\"" 2> /dev/null
    else
        notify-send "git-monitor on '$TARGET': $*" 2> /dev/null
    fi
}


error_nowarn() {
    # Log an error and exit but don't show system notification
    # First argument: error code
    # All others are logged
    retval="$1"
    shift
    printf "git-monitor error [%s]: %s\n" "$TARGET" "$*" >&2; exit "$retval";
}


error() {
    # Log an error and exit
    # First argument: error code
    # All others are logged
    retval="$1"
    shift
    warn "Error: $*"
    error_nowarn "$retval" "$*"
}


######## Git Repo Operations ########

get_git_dir() {
    # Print the git repo directory (.git) or die
    git rev-parse --git-dir || error $? "Not a git repo";
}


get_current_branch() {
    # Return the current branch or die
    local CURR
    if CURR=$(git rev-parse --abbrev-ref HEAD); then
        if [[ -n $CURR && $CURR != "HEAD" ]]; then
            echo "$CURR"
            return 0
        else
            # head checked out
            # or empty branch name (should not be possible)
            error 3 "No active branch."
        fi
     else
        # Git returned error
        error $? "Cannot get active branch."
    fi
}


get_remote_branch() {
    # Detect remote/branch or die
    # Return nothing; instead set REMOTE and BRANCH variables
    BRANCH=$(get_current_branch)
    if REMOTE=$(git config --get "branch.$BRANCH.remote"); then

        if [[ -n $REMOTE ]]; then
            # Check remote branch actually exists
            if git show-ref --quiet --verify -- "refs/remotes/$REMOTE/$BRANCH"; then
                export REMOTE
                export BRANCH
                return 0
            else
                error 3 "No branch named '$BRANCH' on '$REMOTE'."
            fi
        else
            error 3 "No remote configured for branch '$BRANCH'."
        fi
    else
        # Git returned error
        error $? "Cannot get remote for branch '$BRANCH'"
    fi
}


repo_has_changes() {
    git status --porcelain | grep -qE '^(\?\?|[MARC] |[ MARC][MD])*'
}


untracked_files() {
    git status --porcelain | awk '$1 ~ /\?\?/ {print $2;}'
}


check_untracked_file_limits() {
    # Exits with an error if newly added files exceed limits
    FILES=$(untracked_files)
    if [[ -n $FILES ]]; then
        NUM=$($wc -l <<< "$FILES")
        if [[ $NUM -gt $MAX_NEW ]]; then
            error 6 "Too many new files ($NUM)."
        else
            SIZE=$(xargs "$du" -cs <<< "$FILES" | tail -1 | cut -f1)
            if [[ $SIZE -gt $MAX_NEW_SIZE ]]; then
                error 6 "New files are too large (${SIZE}K)."
            fi
        fi
    fi
}


check_local_state_valid () {
    # Exits with an error if repo is in an unsupported state, e.g. rebasing
    local GIT_DIR STATE
    GIT_DIR=$(get_git_dir) || exit $?
	if [[ -f "$GIT_DIR/rebase-merge/interactive" || -d "$GIT_DIR/rebase-merge" ]]; then
		STATE="rebasing"
	else
		if [[ -d "$GIT_DIR/rebase-apply" ]]; then
			STATE="rebasing"
		elif [[ -f "$GIT_DIR/MERGE_HEAD" ]]; then
			STATE="merging"
		elif [[ -f "$GIT_DIR/CHERRY_PICK_HEAD" ]]; then
			STATE="cherry-picking"
		elif [[ -f "$GIT_DIR/BISECT_LOG" ]]; then
			STATE="bisecting"
		fi
	fi
	if [[ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]]; then
		if [[ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]]; then
			STATE="a bare repo"
		else
			STATE="a git-dir"
		fi
	elif [[ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]]; then
		git diff --no-ext-diff --quiet --exit-code || STATE="Dirty"
    fi
    if [[ -n $STATE && "Dirty" != "$STATE" ]]; then
        error 3 "Cannot sync because target is $STATE."
    fi
}

# We keep track of currently occurring sync issues
# So we don't bother the user with an endless stream of notifications
SYNC_PROBLEMS=""

sync_problems(){
    if [[ -n $SYNC_PROBLEMS ]]; then
        # User has had notification; just log
        msg "$1 still failing."
    else
        # New problem; warn
        warn "$1 failed, possibly a networking issue."
        SYNC_PROBLEMS="t"
    fi
}


fetch() {
    get_remote_branch || exit $?
    if git fetch "$REMOTE" "$BRANCH" 2>/dev/null; then
        [[ -n $SYNC_PROBLEMS ]] && msg "Success!"
        SYNC_PROBLEMS=""
    else
        sync_problems "Fetch"
    fi
}


push() {
    msg "Pushing changes..."
    if git push "$REMOTE" "$BRANCH:$BRANCH" 2>/dev/null; then
        [[ -n $SYNC_PROBLEMS ]] && msg "Success!"
        SYNC_PROBLEMS=""
    else
        sync_problems "Push"
    fi
}


merge() {
    msg "Trying fast-forward..."
    git merge --ff --ff-only "$REMOTE/$BRANCH" || error 4 "Error during merge, probably a conflict. Please fix."
}


rebase() {
    msg "We have diverged. Trying to rebase..."
	git rebase "$REMOTE/$BRANCH" || error 4 "Error during rebase, probably a conflict. Please fix."
    # We need to check state after rebase
    check_local_state_valid
    if repo_has_changes; then
        error 4 "Rebasing failed - possible conflicts. Please fix."
    fi
    STATE=$(sync_state) || exit $?
    if [[ $STATE = "ahead" ]]; then
        push
    else
        error 4 "Unexpected state after rebase. Please fix."
    fi
}


sync_state () {
    # determine sync state of repository, i.e. how the remote relates to our HEAD
    # This assumes we have already done a fetch
    local COUNT
    if COUNT="$(git rev-list --count --left-right "$REMOTE/$BRANCH"...HEAD)"; then
        case "$COUNT" in
	        "") # no upstream.. is this possible? get_remote_branch would fail
	            error 3 "branch '$BRANCH' has no upstream"
	            ;;
	        "0	0")
	            echo "equal"
	            ;;
	        "0	"*)
	            echo "ahead"
	            ;;
	        *"	0")
	            echo "behind"
	            ;;
	        *)
	            echo "diverged"
	            ;;
        esac
    else
        error $? "Could not retrieve sync state"
    fi
}

###### Committing ######

make_commit_msg() {
    FILES="$(git status --porcelain)" || error 5 "Cannot get git status."
    NUM=$($wc -l <<< "$FILES")
    printf "Files changed: %s\n\n%s" "${NUM}" "$FILES"
}


commit_local_changes() {
    check_untracked_file_limits

    msg "Committing..."
    if repo_has_changes; then
        git add -A || warn "Cannot add all changes to commit."
        git commit -m "$(make_commit_msg)" >/dev/null || error 4 "Cannot commit changes."
    fi
}


#### Actual syncing ####

do_sync() {
    check_local_state_valid

    commit_local_changes
    fetch

    STATE=$(sync_state) || exit $?
    case "$STATE" in
        "equal")
	        msg "Nothing to do."
            return
	        ;;
        "ahead")
            push
	        ;;
        "behind")
            merge
	        ;;
        "diverged")
            rebase
            ;;
    esac
    STATE=$(sync_state) || exit $?
    if [[ $STATE != "equal" ]]; then
        warn "Local and remote still differ after sync. Please check."
    else
        msg "In sync with $REMOTE"
    fi
}


#### Preliminary checks ####

check_target() {
    # Do some basic checks before starting
    [[ $# -eq 1 ]] || error_nowarn 1 "Need exactly 1 argument: directory to monitor"

    TARGET="$($readlink -f "$1")" || error_nowarn 128 "readlink failed?!"
    [[ -d $TARGET ]] || error 1 "Target '$TARGET' is not a directory."

    cd "$TARGET" || error 2 "Cannot move into target dir '$TARGET'"
    export TARGET
}

####### Main ########

check_target "$@" >/dev/null

msg "Syncing $TARGET"

while true; do
    do_sync
	CHANGE=$($wait_for_change 2>/dev/null)
    [[ -n $CHANGE ]] && msg "Changes detected: $CHANGE"
done
