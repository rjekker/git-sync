#!/usr/bin/env bash -x

# Git Monitor
# Based on git-sync by Simon Thum (Add URL here)
# And the following:
# Took this from: https://github.com/ivanmalison/dotfiles/blob/3a0c142760a930fd41441a645d78ec2a83bf7811/dotfiles/lib/bin/git_sync_directory.sh#L8
# But the fswatch part from: https://github.com/gitwatch/gitwatch/blob/master/gitwatch.sh
# TODO add my own license

# NB we don't care about branches etc.
# We simply sync the current branch with upstream
# So there has to be an upstream
# And a branch on that upstream remote with same name
# Any complication on git status? Just don't do anything

# Note: we DO auto-add new files. Maybe in the future use a limit on file size or number?

# Requirements: bash; git; coreutils and fswatch on Mac OS

# No windows support

declare -r TIMEOUT=60
# shellcheck disable=SC2155
declare -r SYSTEM="$(uname)"

##### Logging and Notification #####

msg() # log message with date
{
    printf "[%s %s] %s\n" "$TARGET" "$(date '+%Y-%m-%d %H:%M:%S')" "$*"
}


warn()
{
    # log message and show it as a system notification
    msg "$*"
    if [[ $SYSTEM = Darwin ]]; then
        osascript -e "display notification \"git-monitor on '$TARGET': $*\"" 2> /dev/null
    else
        notify-send "git-monitor on '$TARGET': $*" 2> /dev/null
    fi
}


error_nowarn() {
    # Log an error and exit but don't show system notification
    # First argument: error code
    # All others are logged
    retval="$1"
    shift
    printf "git-monitor error [%s]: %s\n" "$TARGET" "$*" >&2; exit "$retval";
}


error() {
    # Log an error and exit
    # First argument: error code
    # All others are logged
    retval="$1"
    shift
    warn "Error: $*"
    error_nowarn "$retval" "$*"
}


######## Git Repo Operations ########

get_git_dir() {
    # Print the git repo directory (.git) or die
    git rev-parse --git-dir || error $? "Not a git repo";
}


get_current_branch() {
    # Return the current branch or die
    local CURR
    if CURR=$(git rev-parse --abbrev-ref HEAD); then
        if [[ -n $CURR && $CURR != "HEAD" ]]; then
            echo "$CURR"
            return 0
        else
            # head checked out
            # or empty branch name (should not be possible)
            error 3 "No active branch."
        fi
     else
        # Git returned error
        error $? "Cannot get active branch."
    fi
}


get_remote_branch() {
    # Return remote/branch or die
    BRANCH=$(get_current_branch)
    if REMOTE=$(git config --get "branch.$BRANCH.remote"); then

        if [[ -n $REMOTE ]]; then
            # Check remote branch actually exists
            if git show-ref --quiet --verify -- "refs/remotes/$REMOTE/$BRANCH"; then
                export REMOTE
                export BRANCH
                return 0
            else
                error 3 "No branch named '$BRANCH' on '$REMOTE'."
            fi
        else
            error 3 "No remote configured for branch '$BRANCH'."
        fi
    else
        # Git returned error
        error $? "Cannot get remote for branch '$BRANCH'"
    fi
}


repo_has_changes() {
    git status --porcelain | grep -qE '^(\?\?|[MARC] |[ MARC][MD])*';
}


check_local_state_valid () {
    # Exits with an error if repo is in an unsupported state, e.g. rebasing
    local GIT_DIR STATE
    GIT_DIR=$(get_git_dir) || exit $?
	if [[ -f "$GIT_DIR/rebase-merge/interactive" || -d "$GIT_DIR/rebase-merge" ]]; then
		STATE="rebasing"
	else
		if [[ -d "$GIT_DIR/rebase-apply" ]]; then
			STATE="rebasing"
		elif [[ -f "$GIT_DIR/MERGE_HEAD" ]]; then
			STATE="merging"
		elif [[ -f "$GIT_DIR/CHERRY_PICK_HEAD" ]]; then
			STATE="cherry-picking"
		elif [[ -f "$GIT_DIR/BISECT_LOG" ]]; then
			STATE="bisecting"
		fi
	fi
	if [[ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]]; then
		if [[ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]]; then
			STATE="a bare repo"
		else
			STATE="a git-dir"
		fi
	elif [[ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]]; then
		git diff --no-ext-diff --quiet --exit-code || STATE="Dirty"
    fi
    if [[ -n $STATE && "Dirty" != "$STATE" ]]; then
        error 3 "Cannot sync because target is $STATE."
    fi
    echo "$STATE"
}


fetch() {
    get_remote_branch || exit $?
    msg "Fetching $REMOTE/$BRANCH"
    git fetch "$REMOTE" "$BRANCH" || warn "Cannot fetch, possibly a networking issue."
}


push() {
    msg "Pushing changes..."
	git push "$REMOTE" "$BRANCH:$BRANCH" || warn "Cannot push, possibly a networking issue."
}


merge() {
    msg "Trying fast-forward..."
    git merge --ff --ff-only "$REMOTE/$BRANCH" || error 4 "Error during merge, probably a conflict. Please fix."
}


rebase() {
    msg "We have diverged. Trying to rebase..."
	git rebase "$REMOTE/$BRANCH" || error 4 "Error during rebase, probably a conflict. Please fix."
    # We need to check state after rebase
    check_local_state_valid
    if repo_has_changes; then
        error 4 "Rebasing failed - possible conflicts. Please fix."
    fi
    STATE=$(sync_state) || exit $?
    if [[ $STATE = "ahead" ]]; then
        push
    else
        error 4 "Unexpected state after rebase. Please fix."
    fi
}


sync_state () {
    # determine sync state of repository, i.e. how the remote relates to our HEAD
    # This assumes we have already done a fetch
    local COUNT
    if COUNT="$(git rev-list --count --left-right "$REMOTE/$BRANCH"...HEAD)"; then
        case "$COUNT" in
	        "") # no upstream.. is this possible? get_remote_branch would fail
	            error 3 "branch '$BRANCH' has no upstream"
	            ;;
	        "0	0")
	            echo "equal"
	            ;;
	        "0	"*)
	            echo "ahead"
	            ;;
	        *"	0")
	            echo "behind"
	            ;;
	        *)
	            echo "diverged"
	            ;;
        esac
    else
        error $? "Could not retrieve sync state"
    fi
}

###### Committing ######

# A function to reduce git diff output to the actual changed content, and insert file line numbers.
# Based on "https://stackoverflow.com/a/12179492/199142" by John Mellor
diff-lines() {
    local path=
    local line=
    local previous_path=
    while read; do
        esc=$'\033'
        if [[ $REPLY =~ ---\ (a/)?([^[:blank:]$esc]+).* ]]; then
            previous_path=${BASH_REMATCH[2]}
            continue
        elif [[ $REPLY =~ \+\+\+\ (b/)?([^[:blank:]$esc]+).* ]]; then
            path=${BASH_REMATCH[2]}
        elif [[ $REPLY =~ @@\ -[0-9]+(,[0-9]+)?\ \+([0-9]+)(,[0-9]+)?\ @@.* ]]; then
            line=${BASH_REMATCH[2]}
        elif [[ $REPLY =~ ^($esc\[[0-9;]+m)*([\ +-]) ]]; then
            REPLY=${REPLY:0:150}           # limit the line width, so it fits in a single line in most git log outputs
            if [[ "$path" == "/dev/null" ]]; then
                echo "File $previous_path deleted or moved."
                continue
            else
                echo "$path:$line: $REPLY"
            fi
            if [[ ${BASH_REMATCH[2]} != - ]]; then
                ((line++))
            fi
        fi
    done
}

make_commit_msg() {
    MSG="$(git diff -U0 --color=always | diff-lines)"
    LENGTH=$(echo -n "$MSG" | grep -c '^')

    if [[ $LENGTH -le 10 ]]; then
        # Use git diff as the commit msg, unless if files were added or deleted but not modified
        if [[ -n $MSG ]]; then
            FORMATTED_MSG="$MSG"
        else
            FORMATTED_MSG="New files added: $(git status -s)"
        fi
    else
        FORMATTED_MSG=$(git diff --stat | grep '|')
    fi
    echo "$FORMATTED_MSG"
}

commit_local_changes() {
    if repo_has_changes; then

        git add -A || warn "Cannot add all changes to commit."
        git commit -m "$(make_commit_msg)" || error 4 "Cannot commit changes."
    fi
}

###### Detecting changes ######

wait_for_change() {
    # Wait for $TIMEOUT seconds for a change
    if [[ $SYSTEM != "Darwin" ]]; then
        inotifywait . -r -e modify,move,create,delete --format "%w%f" --exclude "\.git" -t "$TIMEOUT"
    else
        # default events specified via a mask, see
        # https://emcrisostomo.github.io/fswatch/doc/1.14.0/fswatch.html/Invoking-fswatch.html#Numeric-Event-Flags
        # default of 414 = MovedTo + MovedFrom + Renamed + Removed + Updated + Created
        #                = 256 + 128+ 16 + 8 + 4 + 2
        gtimeout "$TIMEOUT" fswatch --recursive --event=414 --exclude "\.git"  -1 .
    fi
}

#### Actual syncing ####

do_sync() {
    check_local_state_valid

    msg "Syncing $TARGET"
    commit_local_changes
    fetch

    STATE=$(sync_state) || exit $?
    case "$STATE" in
        "equal")
	        msg "In sync with $REMOTE"
	        ;;
        "ahead")
            push
	        ;;
        "behind")
            merge
	        ;;
        "diverged")
            rebase
            ;;
    esac
    STATE=$(sync_state) || exit $?
    if [[ $STATE != "equal" ]]; then
        warn "Local and remote still differ after sync. Please check."
    fi
}


#### Preliminary checks ####

check_target() {
    # Do some basic checks before starting
    readlink="readlink"
    if [[ $SYSTEM = "Darwin" ]]; then
        command -v gtimeout >/dev/null || error_nowarn 1 "Please install coreutils."
        command -v fswatch >/dev/null || error_nowarn 1 "Please install fswatch."
        readlink="greadlink"
    fi

    [[ $# -eq 1 ]] || error_nowarn 1 "Need exactly 1 argument: directory to monitor"

    TARGET="$($readlink -f "$1")" || error_nowarn 128 "readlink failed?!"
    [[ -d $TARGET ]] || error 1 "Target '$TARGET' is not a directory."

    cd "$TARGET" || error 2 "Cannot move into target dir '$TARGET'"
    export TARGET
}

####### Main ########

check_target "$@" >/dev/null

while true; do
    do_sync
	wait_for_change 2>/dev/null
done
